import os
import csv
import shutil
import tempfile

import numpy as np
import torch
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap
from matplotlib import patches
import pyvista as pv

from shapes.invertible_nn import ConvexDiffeo


# ------------------------------------------------------------------
# Backend configuration
# ------------------------------------------------------------------

# Fully non-interactive matplotlib backend (avoids memory issues)
matplotlib.use("Agg")

# Force PyVista off-screen rendering
pv.OFF_SCREEN = True


# ------------------------------------------------------------------
# High-level plotting utilities
# ------------------------------------------------------------------

def plot_all_shapes(models, x, out_folder, plot_meshes=False, video=False):
    """
    Plot a diagram and a collection of shapes generated by ConvexDiffeo models.

    This function:
    - Saves each model to disk
    - Plots the corresponding shape
    - Generates a CSV file mapping diagram points to shape images

    The CSV file has columns:
        img_src, x, y

    Parameters
    ----------
    models : list[ConvexDiffeo]
        List of trained models defining shapes.
    x : array-like, shape (N, 2)
        Diagram coordinates associated with each model.
    out_folder : str
        Output directory where plots, models, and CSV are saved.
    plot_meshes : bool, optional
        If True, also plot a finite-element mesh of the 2D shape.
    video : bool, optional
        If True, generate rotating 3D videos instead of static images.
    """
    shapes_folder = os.path.join(out_folder, "shapes")
    models_folder = os.path.join(out_folder, "models")

    # Recreate output folders
    shutil.rmtree(shapes_folder, ignore_errors=True)
    shutil.rmtree(models_folder, ignore_errors=True)
    os.makedirs(shapes_folder, exist_ok=True)
    os.makedirs(models_folder, exist_ok=True)

    csv_path = os.path.join(shapes_folder, "diagram.csv")

    with open(csv_path, mode="w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["img_src", "x", "y"])

        for i, model in enumerate(models):
            # Save model checkpoint
            model_path = os.path.join(models_folder, f"{i}.pt")
            torch.save(model, model_path)

            # Output image or video filename
            img_name = f"{i}.mp4" if video else f"{i}.png"
            img_path = os.path.join(shapes_folder, img_name)

            # Plot shape
            plot_shape(
                model,
                output=img_path,
                video=video,
                plot_mesh=plot_meshes,
            )

            # CSV entry (relative path for HTML usage)
            writer.writerow([img_name, x[i, 0], x[i, 1]])

    print(f"Saved shapes, models, and CSV to {out_folder}")


def plot_diagram(x, output, xlim=(0, 1), ylim=(0, 1), color=None, cmap="cool_r"):
    """
    Plot a 2D diagram of points.

    Intended for visualizing parameter spaces or embeddings
    associated with shape collections.

    Parameters
    ----------
    x : array-like, shape (N, 2)
        Point coordinates.
    output : str
        Path where the image is saved.
    xlim : tuple, optional
        X-axis limits.
    ylim : tuple, optional
        Y-axis limits.
    color : array-like or None
        Scalar values used for coloring points.
    cmap : str
        Matplotlib colormap name.
    """
    fig, ax = plt.subplots()

    size = 4
    my_cmap = get_cmap(cmap)
    my_cmap.set_bad(color="red")

    if color is None:
        color = np.zeros(x.shape[0])

    # Layered scatter for glow-like effect
    plt.scatter(x[:, 0], x[:, 1], s=20 * size, c=color,
                cmap=my_cmap, marker=".", alpha=0.1, plotnonfinite=True)
    plt.scatter(x[:, 0], x[:, 1], s=5 * size, c=color,
                cmap=my_cmap, marker=".", alpha=0.3, plotnonfinite=True)
    plt.scatter(x[:, 0], x[:, 1], s=1 * size, c=color,
                cmap=my_cmap, marker=".", plotnonfinite=True)

    plt.xlim(xlim)
    plt.ylim(ylim)

    ax.set_facecolor("#000114")
    ax.set_aspect("equal", "box")

    fig.savefig(output, dpi=200, bbox_inches="tight")
    plt.close(fig)


def plot_shape(model, output, n_points=500, video=False, plot_mesh=False):
    """
    Dispatch shape plotting based on dimension and output type.

    Parameters
    ----------
    model : ConvexDiffeo
        Shape-defining model.
    output : str
        Output file path.
    n_points : int
        Resolution of boundary sampling.
    video : bool
        If True and dim=3, generate a rotating video.
    plot_mesh : bool
        If True and dim=2, overlay a finite-element mesh.
    """
    if model.dim == 2:
        plot_shape_2d(model, output, n_points)

    if model.dim == 3 and not video:
        plot_shape_3d(model, output, n_points)

    if model.dim == 3 and video:
        plot_shape_3d_movie(model, output, n_points)

    if plot_mesh:
        from skfem_mesh_utils import create_2d_moved_mesh_mmg
        import skfem as fem
        from skfem.visuals.matplotlib import draw

        with tempfile.TemporaryDirectory() as tmpdir:
            mesh_file = os.path.join(tmpdir, "boundary.mesh")

            create_2d_moved_mesh_mmg(
                model,
                rel_mesh_size=model.mesh_length,
                output=mesh_file,
            )

            moved_mesh = fem.MeshTri.load(mesh_file)
            draw(moved_mesh)
            plt.savefig(output)
            plt.close()


# ------------------------------------------------------------------
# 2D plotting
# ------------------------------------------------------------------

def plot_shape_2d(model, output, n_points=500):
    """
    Plot the boundary of a 2D convex shape.

    Parameters
    ----------
    model : ConvexDiffeo
        2D shape model.
    output : str
        Output image path.
    n_points : int
        Number of boundary samples.
    """
    device = next(model.parameters()).device
    dtype = next(model.parameters()).dtype

    theta = torch.linspace(0, 2 * torch.pi, n_points,
                           device=device, dtype=dtype)
    boundary = torch.stack([torch.cos(theta), torch.sin(theta)], dim=1)

    with torch.no_grad():
        boundary = model(boundary).cpu().numpy()

    fig, ax = plt.subplots()

    polygon = patches.Polygon(
        boundary,
        closed=True,
        fill=True,
        edgecolor="teal",
        linewidth=1,
    )
    ax.add_patch(polygon)

    ax.set_aspect("equal", "box")
    ax.axis("off")
    ax.autoscale_view()

    plt.savefig(output, bbox_inches="tight", pad_inches=0)
    plt.close(fig)


# ------------------------------------------------------------------
# 3D plotting
# ------------------------------------------------------------------

def plot_shape_3d(model, output, n_points=1000, window_size=(800, 800)):
    """
    Render a 3D shape using PyVista (static image).

    Parameters
    ----------
    model : ConvexDiffeo
        3D shape model.
    output : str
        Output image path.
    n_points : int
        Sphere resolution.
    window_size : tuple
        Rendering window size in pixels.
    """
    device = next(model.parameters()).device
    dtype = next(model.parameters()).dtype

    sphere = pv.Sphere(
        radius=1.0,
        theta_resolution=n_points,
        phi_resolution=n_points,
    )

    points = torch.tensor(sphere.points, device=device, dtype=dtype)

    with torch.no_grad():
        mapped = model(points).cpu().numpy()

    mesh = pv.PolyData(mapped, sphere.faces)

    plotter = pv.Plotter(off_screen=True, window_size=window_size)

    z = mapped[:, 2]
    mesh["z"] = (z - z.min()) / (z.max() - z.min())

    plotter.add_mesh(
        mesh,
        scalars="z",
        cmap="plasma",
        smooth_shading=True,
        specular=0.6,
        ambient=0.3,
        diffuse=0.6,
        show_scalar_bar=False,
    )

    plotter.add_light(pv.Light(position=(5, 5, 5), focal_point=(0, 0, 0), intensity=0.1))
    plotter.add_light(pv.Light(position=(-3, -3, 2), focal_point=(0, 0, 0), intensity=0.2))

    plotter.show(screenshot=output)
    plotter.close()


def plot_shape_3d_movie(model, output, n_points=100, window_size=(800, 800)):
    """
    Render a rotating 3D animation of a shape.

    Parameters
    ----------
    model : ConvexDiffeo
        3D shape model.
    output : str
        Output video path (mp4).
    n_points : int
        Sphere resolution.
    window_size : tuple
        Rendering window size in pixels.
    """
    device = next(model.parameters()).device
    dtype = next(model.parameters()).dtype

    sphere = pv.Sphere(
        radius=1.0,
        theta_resolution=n_points,
        phi_resolution=n_points,
    )

    points = torch.tensor(sphere.points, device=device, dtype=dtype)

    with torch.no_grad():
        mapped = model(points).cpu().numpy()

    mesh = pv.PolyData(mapped, sphere.faces)

    plotter = pv.Plotter(off_screen=True, window_size=window_size)

    z = mapped[:, 2]
    mesh["z"] = (z - z.min()) / (z.max() - z.min())

    plotter.add_mesh(
        mesh,
        scalars="z",
        cmap="plasma",
        smooth_shading=True,
        specular=0.6,
        ambient=0.3,
        diffuse=0.6,
        show_scalar_bar=False,
    )

    plotter.add_light(pv.Light(position=(5, 5, 5), focal_point=(0, 0, 0), intensity=0.1))
    plotter.add_light(pv.Light(position=(-3, -3, 2), focal_point=(0, 0, 0), intensity=0.2))

    plotter.open_movie(output, framerate=30)

    n_frames = 120
    for _ in range(n_frames):
        plotter.camera.Azimuth(360 / n_frames)
        plotter.render()
        plotter.write_frame()

    plotter.close()


# ------------------------------------------------------------------
# Script usage
# ------------------------------------------------------------------

if __name__ == "__main__":
    model = ConvexDiffeo(input_size=2, n_unit=50)
    plot_shape(model, output="example.png")
